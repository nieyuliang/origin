###布尔类型

>只有两个值：true/false

如何把其它数据类型转换为布尔类型？

-Boolean
-!
-!!

、、、javascript
Boolean(1) =>true

!'珠峰培训' =>先把其它数据类型转换为布尔类型，然后取反

！！null=>取两次反，等价于没有取反，也就剩下转换为布尔类型了

、、、

(重点)规律：在JS中只有“0/NaN/空字符串/null/undefined”这五个值转换为布尔类型的false,其余都转换为true

---------------------------------------------
null && undefined
>都代表空或者没有

>-null:空对象指针

>-undefined:未定义


null一般都是意料之中的没有（通俗理解：一般都是人为手动的先赋值为null，后面的程序中我们会再次给他赋值）

、、、javascript

var num = null;//=>null是手动赋值，预示着后面我会把num变量的值进行修改

。。。。。。

num=12；

、、、


undefined代表的没有，一般都不是人为手动控制的，大部分都是浏览器自主为空（后面可以赋值也可以不赋值）

、、、javascript
var num;//=>此时变量的值浏览器给分配的就是undefined

....
后面可以赋值也可以不赋值

、、、

-------------------------------
###object 对象数据类型
>普通对象
>-由大括号包裹起来的
>-由零到多组属性名和属性值（键值对）组成


属性是用来描述当前对象特征的，属性名是当前具备这个特征，属性值是对这个特征的描述（专业语法，属性名称为键【key】,
属性值称为值【value】,一组属性名和属性值称为一组键值对）

、、、javascript
var obj = {

    name: ‘珠峰培训’，
    age:9

};
//=>对象的操作：对键值对的增删改查

【获取】
语法：对象.属性名/ 对象[属性]
obj.name
obj['name']  一般来说，对象的属性名都是字符串格式的
（属性值不固定，任何格式都可以）

【增/改】
JS对象中，属性名是不允许重复的，是唯一的

obj.name='周小天'；//=>原有对象中存在name属性，此处属于修改属性值

obj.sex='男'；//=>原有对象中不存在sex，此处相当于给当前对象新增加一个属性sex

【删】
彻底删除：对象中不存在这个属性了
 delete obj['age'];

假删除：并没有移除这个属性，只是让当前属性的值为空

obj.sex=null;

在获取属性值的时候，如果当前对象有这个属性名，则可以正常获取到值（哪怕是null）,但是如果没有这个属性名，则获取的结果是undefined

obj['friends'] =>undefined

思考题：
、、、javascript
var obj = {

   name:'珠峰培训',
   age:9
};

var name = ‘zhufeng’;

obj.name  =>‘珠峰培训’ 获取的是name属性的值

obj['name']  =>‘珠峰培训’ 获取的是name属性的值
 
obj[name] =>此处的name是一个变量，我们要获取的属性名不叫做name,是name 存储的值‘zhufeng’
=>obj['zhufeng'] =>没有这个属性，属性值是undefined


---------------
'name'和name 的区别？

=>'name'是一个字符串值，它代表的是本身

=>name是一个变量，它代表的是本身存储的这个值

、、、

一个对象中的属性名不仅仅是字符串格式的，还有可能是数字格式的 
、、、
var obj = {
    name:'珠峰培训',
    0:100
}；

obj[0]  =>100
obj['0'] =>100
obj.0 =>IUncaught SyntaxError :Unexpected number 语法错误的意思


当我们储存是属性名不是字符串也不是数字的时候，浏览器会把这个值转换 为字符串（toString）,然后再进行存储


obj[{}]=300; =>先把（{}）.toString()后的结果作为对象的属性名储存进来  obj['[object Object]']=300


obj[{}] =>获取的时候也是先把对象转换为字符串‘[object Object]’,然后获取之前储存的 300
、、、
------------
数组对象（对象由键值对组成的）

var oo = {

   a:12
};

var ary = [12,23 ];//=>12和23都是属性值，属性名呢？

通过观察结果，我们发现数组对象的属性名是数字（我们把数字属性名称为当前对象的索引）

ary[0]
ary['0']

ary.0 =>报语法错误


----------------------------------------------
浅分析JS的运行机制
1、当浏览器（它的内核\引擎）渲染和解析JS的时候，会提供一个供JS代码运行的环境，我们把这个环境称之为“全局作用域（global/window  scope）”

2、代码自上而下执行（之前还有一个变量提升阶段）
   =》基本数据类型的值会存储在当前作用域下
---------------------------------------------
 var a = 12;  分三步

1)首先开辟一个空间储存12
2）在当前作用域中声明一个变量a (var a )
3)让声明的变量和储存的12进行关联（把存储的12赋值给a=>赋值操作叫做定义）
---------------------------------
基本数据类型（也叫作值类型），是按照值来操作的：把原有的值复制一份，放到新的空间或者位置上，和原来的值没有关系

==》引用数据类型的值不能直接存储到当前的作用域下（因为可能存储的内容过于复杂），我们需要先开辟一个新的空间（理解为仓库），
把内容存储到这个空间中

var obj1 = {n:100};
1)首先开辟一个新的内存空间，把对象中的键值对依次存储起来（为了保证后面可以找到这个空间，此空间有一个16进制的地址）

2）声明一个变量

3）让变量和空间地址关联在一起（把空间地址赋值给变量）

引用类型不是按照值来操作，它操作的是空间的引用地址：把原来空间的地址赋值给新的变量，但是原来的空间没有被克隆，还是一个空间，
这样就会出现多个变量关联的是相同的空间，相互之间就会存在影响了

栈内存（全局作用域）：本身就是一个供JS代码执行的环境。所有的基本类型值都会直接在栈内存中开辟一个位置进行存储

堆内存：用来存储引用类型中的信息值的，对象存储的是键值对，函数存储的是代码字符串

------------------------------
var obj = {
     n:10,
     m:obj.n*10

}；
console.log(obj.m);=>Uncaught TypeError:Cannot read
property 'n' of undefined

1、形成一个全局作用域（栈内存）
2、代码自上而下执行
   1、首先开辟一个新的堆内存（AAAFFF111），把键值对存储到堆内存中
   n:10
   m:obj.n*10  =>obj.n 此时堆内存信息还没有存储完成，空间的地址还没有给obj,此时的obj undefined,
obj.n<=>undefined.n  undefined属于基本数据类型，没有属性 只有对象类型才有属性名  所以undefined 无法读取n 

--------------------------------------------------
##JS中的判断操作语句
if/else if/else

var num=12;

if(num>10){
  num++;//=>num=num+1  num+=1 在自身的基础上累加1

}else if(num>=0 && num<=10){
   num--;

}else{

   num+=2;
}
console.log(num);


只要有一个条件成立，后面不管是否还有成立条件，都不在判断执行了


关于条件可以怎么写？
//>=  /<=  /==  常规比较

if(0){
   //==>不管你在条件判断中写什么，最后总要把其计算出true/false 来判断条件是否成立（把其它类型的值转换为布尔类型，
只有 0/NaN/''/null/undefined是false,其余都是true）

}

--------------
if('3px'+3){
  //=>在JS中，+ - * / % 都是数学运算，除+ 以外，其余运算符在运算的时候，如果遇到了非数字类型的值，
首先会转换为数字类型(Number),然后再进行运行


==》+ 在JS中除了数学相加，还有字符串拼接的作用（如果运算中遇到了字符串，则为字符串拼接，而不是数学相加）

‘3px’+3 =>'3px3'
}

if('3px'-3){
  
   // '3px'-3  =>NaN  判断为假 不执行

}


检测在JS中用来检测数据类型的方式(背下来)
>-typeof
>-instanceof
>-constructor
>-Object.prototype.toString.call()

语法：typeof[value] 检测value的数据类型


返回值：使用typeof检测出来的结果是一个字符串，字符串中包含着对应的数据类型，
例如：“number”/"string"/"boolean"/"undefined"/"object"/"function"

typeof null =>"object"因为null代表空对象指针（没有指向任何的内存空间）

typeof 检测数组/正则/对象，最后返回的都是“object”,也就是基于这种方式无法细分对象


面试题：

console.log(typeof []);

//=>"object"

console.log(typeof typeof []);
//=>typeof "object"
//=>"string"
--------------------
var num = parserInt('width:35.5px');
if (num==35.5){
   alert(0);
}else if (num==35){

   alert(1);
}else if (if num=NaN){
   alert(2);
}else if (typeof num=="number"){
//=>先算 typeof num
//=>在做比较
   alert(3);//=>alert 输出的都是字符串格式的‘3’

}else{

   alert(4);
}
-------------------------------

2、三元运算符

语法：条件？成立做的事情：不成立做的事情;
《==》相当于简单的if/else判断

num>10?num++:num--;

特殊情况
//=>如果三元运算符中的某一部分不需要做任何的处理，我们用 null/undefined/void 0 等等占位即可

var num = 12;

num>10?num++:null;

//==>如果需要执行多项操作，我们把其用小括号包裹起来，每条操作语句用逗号分隔

num=10；
num>=10?(num++,num*=10):null;


num>0?(num<10?num++:num--):(num==0?(num++,num=num/10):null);
---------------------
3、switch case

JS中的一种判断方式



//=>switch case 应用于变量（或者表达式等）在不同值情况下的不同操作，每一种case结束后都要加break（结束整个判断）
var num=10;
switch(num){
    case 10:
        num++;
        break;

case 5:
        num--;
        break;
 default:
       num=0;


}

//=>switch case 应用于变量（或者表达式等）在不同值情况下的不同操作，每一种case结束后都要加break（结束整个判断）
----------------------
switch case 中每一种case情况的比较都是基于“===”绝对相等来完成的

'10'==10 =>true 相等比较，如果符号左右两边的类型不一样，首先会转换为一样的数据类型，然后再进行比较。
=》当前案例中，就是把字符串‘10’转换为数字了，然后再比较的


'10'===10 绝对比较，如果两边的数据类型不一样，则直接不相等，它要求类型和值都完全一样才会相等（真实项目中为了保证代码的严谨性，我们应该更多使用绝对比较）

var num = 10;
switch (num){
  case 10:
  case 5:

       num--;
       break;
  
    default:
       num=0;

}
console.log(num);
//=>不加break,后面的条件不管是否成立，都会被执行;利用此机制，我们可以完成一些特殊的处理，例如：如果num等于10和等于5都要做同一件事情，那么我们写在一起，不用加break即可






















