GIT工作原理及操作

>当我们在本地创建一个git仓库后，我们可以基于这个仓库管理我们的代码

git的工作流程
>每一个git仓库都划分为三个区域
>工作区：编辑代码的地方
>暂存区:临时存储要生成版本代码的地方
>历史区：存储的是生成的每一个版本代码



工作区提交到暂存区
>git status
>查看代码或者文件的状态（当前处于哪个区域）：红色（当前处于工作区，还没有提交到暂时区）绿色（当前处于暂存区，还没有提交到历史区）
如果没有文件，代表三个区域代码已经同步，历史版本也在历史区生成了


git add  ./git add  -A
把当前工作区中所有最新修改的文件，都提交到暂存区

工作区提交到暂存区，暂存区提交到历史区（重点记住暂存区始终存放提交的内容，并没有消失，以后工作区内容修改，会和暂存区作对比，
依次来判断哪些是新处理的）

暂存区到历史区

git commit
>这样执行后，会弹出一个提交文本输入界面，需要我们编写本次提交到历史区，给当前版本编写的备注信息


>先按i进入编辑插入模式
>输入备注信息
>按ESC
>输入“：wq”保存并退出


常用的：git commit -m‘自己需要编写的备注信息’

git log
查看当前历史区 提交的记录（查看版本信息）

git diff
工作VS暂存区


git diff master
工作区VS历史区（master分支）


git diff --cached
暂存区VS历史区


git 和 gitHub同步
1、让本地的git仓库和远程仓库建立关联

git remote -v
查看所有的关联信息

git remote add xxx [远程仓库git地址]
建立关联



git remote remove  xxx
移除关联

我们远程仓库关联在一起的名字默认是：origin,当然自己可以随意修改


2、把本地的信息推送到远程仓库上，或者从远程仓库上拉取最新的信息到本地仓库

>我们本地推送和拉取的信息，既有代码也有版本信息，所以说 与其说是推送和拉取，不如说是和远程仓库保持信息的同步

在推送之前，我们都应该先拉取

git pull origin(这个名字是和远程仓库关联的这个名字，以自己设置的为主) master
从远程仓库的master分支拉取最新的信息

git push origin master
把自己本地的信息推送到远程仓库的master分支下

--------------------
以上是操作知识点，真实项目开发流程

1.leader 会首先创建一个远程仓库（这个仓库可能是空的，也可能是包含了项目需要的基础的结构信息）

2.作为开发者，我们需要在本地创建一个本地仓库，还需要让当前本地的仓库和远程仓库保持关联


原始做法：

>git init
>git remote add origin [GIT仓库地址]



>简单做法；
>git clone[远程仓库地址][克隆后的名字：可以不设置，默认是仓库名]


3.在本地开发产品，需要同步的时候，我们首先把工作区内容在本地仓库中放到历史区，生产版本信息（git add ./git commit -m''）,在把本地历史区的信息推送到远程仓库上（git pull/git push）


4.在团队协作开发的时候，leater会在自己的GitHub账号下创建一个远程仓库，那么团队其他成员在向这个远程仓库推送信息的时候，使用自己的账号是没有推送权限的，我们需要把当前这个远程仓库，在GitHub中创建工作群组，让更多人使用自己的账号也有操作权限。
小组成员在自己的邮箱中收到一封邀请邮件，需要确认同意

-------------------------

栈内存：作用域
1、提供一个供JS代码自上而下执行的环境（代码都是在栈中执行的）
2、由于基本数据类型值比较简单，他们都是直接在栈内存中开辟一个位置，把值直接存储进去的
=》当栈内存被销毁，储存的那些基本值也都跟着销毁了


堆内存：引用值对应的空间
1、存储引用类型值的（对象：键值对  函数：代码字符串）
=》当前堆内存释放销毁，那么这个引用值彻底没了
=》堆内存的释放：当堆内存没有被任何的变量或者其它东西所占用，浏览器会在空闲的时候，自主的进行内存回收，把所有不被占用的堆内存销毁掉（谷歌浏览器）


xxx=null 通过空对象指针null可以让原始变量（或者其它东西）谁都不指向，那么原有被占用的堆内存就没有被东西占用了，浏览器会销毁它

变量提升：当栈内存（作用域）形成，JS代码自上而下执行之前，浏览器首先会把所带“VAR”/“FUNCTION”关键词的进行提前“声明”或者“定义”，这种预先处理机制称之为“变量提升”

=》声明（declare）:var a （默认值undefined）
=>定义（defined）：a=12 (定义其实就是赋值操作)

【变量提升阶段】
=》带“VAR”的只声明未定义
=》带“FUNCTION”的声明和赋值都完成了

=》变量提升只发生在当前作用域（例如：开始加载页面的时候只对全局作用域下的进行提升，因为此时函数中存储都是字符串而已）

=》在全局作用域下声明的函数或者变量是“全局变量”，同理，在私有作用 域下声明的变量是“私有变量”[带VAR/FUNCTION的才是声明]

=》浏览器很懒，做过的事情不会重复执行第二遍，也就是，当代码执行遇到创建函数这部分代码后，直接的跳过去即可（因为在提升阶段就已经完成函数的赋值操作了）


=》私有作用域形成后也不是立即代码执行，而是先进行变量提升（变量提升前，先形参赋值）

=》在ES3/ES5语法规范中，只有全局作用域和函数执行的私有作用 域（栈内存），其它大括号不会形成栈内存

------------
在全局作用域下声明一个变量，也相当于给WINDOW全局对象设置了一个属性，变量的值就是属性值（私有作用域中声明的私有变量和WINDOW没有关系）
console.log(a);//=>undefined
console.log(window.a);//=>undefined
console.log('a' in window);//=>ture 在变量提升阶段，在全局作用域中声明了一个变量A，此时就已经把A当做属性赋值给WINDOW了，只不过此时还没有给A赋值，默认值ENDEFINED in:检测某个属性是否隶属于这个对象
var a =12;//=>全局变量值修改，WIN的属性值也跟着修改
console.log(a)//=>全局变量A 12
console.log(window.a);//=>WINDOW的一个属性名 A 12

a=13;
console.log(window.a);//=>13

window.a=14;
console.log(a);//=>14
//=>全局变量和WIN中的属性存在“映射机制”


//=>不加VAR的本质是WIN的属性
console.log(window.a);//=>undefned

console.log('a' in window);//=>false
a=12;//=>window.a=12
console.log(a);//=>12
console.log(window.a);//=>12

var a=12,b=14;//=>这样写B是带VARD 

var a=b=12;//=>这样写b是不带VAR的

---------------------------
私有作用域中带VAR和不带也是有区别
1、带VAR的在私有作用域变量提升阶段，都声明为私有变量，和外界没有任何的关系
2、不带VAR不是私有变量，会向它的上级作用域查找，看是否为上级的变量，不是，继续向上查找，一直找到window为止（我们把这种查找机制叫做：“作用域链”），也就是我们在私有作用域中操作的这个非私有变量，是一直操作别人的

-------------------------
function fn(){
   //变量提升：无
   b=13;
   //console.log('b' in window);//=>true 在作用域链查找的过程中，如果找到WIN也没有这个变量，相当于给WIN设置了一个属性B

(window.b=13)
  console.log(b);//=>13


}

fn();
console.log(b);//=>13













