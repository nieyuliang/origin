

function fn(n,m){ //=>形参：入口

   //=>函数体
   var total = 0;
   total = n+m;
    console.log(total);
}
 fn(10,20);//=>实参：给形参传递的具体值
var a = 12;
fn(a,1 === 1?10:0); //=>实参一定是值，即使我们写的是变量或者表达式，也是把变量或者表达式计算的结果作为值传递给形参变量
-----------------------
函数执行的时候，都会形成一个全新的私有作用域（私有的栈内存），目的是：
1、把原有堆内存中存储的字符串变为JS表达式执行
2、保护里面的私有变量不受外界的干扰（和外界是隔离的）
我们把函数执行的这种保护机制，称之为“闭包”

----------------------
函数的入口：形参
函数的出口：返回值  return
 把函数运行的结果（或者函数体中的部分信息）拿到函数外面去使用 


return total; =>并不是把total变量返回，返回的是变量存储的值，return返回的永远是一个值 

fn => 代表的是函数本身
fn（10,20） =》代表的是函数执行（不仅如此，它代表的是函数执行后，返回的结果[return返回的值]）

console.log(fn(1,2));  //=>3

var result = fn(1,2);
console.log(result);  //=>3

如果当前函数没有return结果出来（或者return;什么也没有返回），函数执行 在外面拿到的结果是 undefined

例如：
function fn(n,m){
  
   if(n===undefined || m===undefined){
     return 0; //=>return还有一个作用：类似于循环中的break，能够强制结束函数体中代码的执行（return后面的代码不在执行）
    }
   var total = 0;
   total = n+m;
   return；  //=》undefined
}
--------------------
n===undefined 经常这样判断n的值是否为undefined，这种方式可以

n==undefined 这种模式不好，因为null==undefined也是相等的（===比较才不相等）

typeof n==‘undefined’真实项目中开发者更喜欢这种判断模式

total=0；0是有值的，值是0，从内存方面来说，会在栈内存中占一个位置

total=null；开发者更喜欢用null来作为初始值，null是空对象指针，是不占内存位置的
-----------------
形参有局限性：我们需要具体的知道用户执行的时候传递实参变量、顺序等，才可以使用形参变量定义对应的入口

arguments:函数内置的实参集合（内置：函数天生就存在的机制，不管你是否设置了形参，也不管你是否传递了实参，arguments都有，始终存在）

function sum（n,m）{

   console.log(arguments);
   //arg它是一个类数组（不是数组，不能直接使用数组中的    方法）
   //即使设置形参变量，形参该是什么值还是什么值，但是arg使用存储的是“所有”传递进来的实参，所以它被称为“实参集合”
}
{
 0:10，
 1:20，
 length：2， 
 callee:存储的是当前函数本身 arguments.callee===sum:true
}


-----------------------
实名函数：有函数名的
匿名函数：没有函数名的
 --函数表达式：把函数当做值赋值给变量或者元素的事件
 --自执行函：创建和执行一起完成的
//=>函数表达式

var fn = function () {

};

oBox.onclick = function(){

};

----------------
=>自执行函数

（function（）{

}）（）；


~function（）{

}（）；

+function（）{

}（）；

！function（）{

}（）；














